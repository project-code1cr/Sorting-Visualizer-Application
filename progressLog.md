# PROGRESS

## DAY 1
   Did a light review of React, relearning about componenets, jsx, and the basic react syntax

## Day 2
   Downloaded Node, had many errors figuring out how to get create-react-app to work. This was some problem due to an incompatible nodejs version. Once this error was fixed through updating npm using the command 'npx update npm'

   Now I officially started on the project. I started by creating a basic layout of how I wanted my app to look. I included buttons for the algorithms I wanted to animate/visualise: bubble sort, mergesort, quicksort, insertion sort,selection sort. I created a Sorting visualizer component to house the bars. When trying to display this component on the app for some reason nothing was showing up. Turns out I had 2 errors: I wrote my import line wrong and components need to be capitalized. 

   Once I was able to get things to finally show up I needed to figure out how to get the bars working. I started with using borders, but I had issues of making all the bars the same width and giving them dynamic lengths. After reading a bit about css online I ditched the idea of using borders and make the bars with using padding-bottom to deal with the length and padding-left and padding-right along with text-size = 0 to make it so all the bars are equal width. To make these values dynamic I decided to add them in the component js file when rendering.

## Day 3
   I finally started coding the algorithms. I started with bubble sort as it was the easiet. I ran into some problems importing the js function, learning that I needed export function on the function I wanted to be called, and also having '../../ [Folder]/[filename].js', main issue was the fact that I needed to go up 2 folders. Coding the algorithm was easy but the real problem came when I realized I needed to figure out a way to acutally animate the algorithm showing all the steps. After some basic deliberation and researching online, I saw that I could create a array to house whenever a swap or move was made and which element were involved then create a function in my sortervisuals.js component to follow that plan. I started with having an array to tuple esc values, making it formated something like [didSwapElements?, elementIdx1, elementIdx2]. I implemented this in my bubbleSort.js then started on the animate function. 

   For the animate function I just made it iterate through the plan and made it a certain color of didSwap was false, if that was true I made it another color and swapped the values in the state array, then did this.setState. I ran into errors during this step as I had to refresh on how to update a state variable. 

   One this was figure out I had run into another problem everyhting was happening instantly so I did not know how to make it have some form of interval between each step. After some reading on the web I figured I could use the setTimeout function. At first I made the timeout speed 5 seconds but ran into the same problem, I had believed that the setTimeout function would sleep and wait the time before continuing the code, however what it was really doing was putting the operation to the side, saying "hey I will do this in x seconds" and continues running and once x seconds are over it goes back and runs that section of code. I then realixed I could make it so the  timeout is the 'moveTime * moveNumber'. In this case lets say moveTime was 5 seconds in a seperate wait stack the code would wait 5 seconds to run move 1, 10 seconds for move 2, 15 for move 3 and so on; this makes it so every move is essentially seperated by 5 seconds. 

## Day 4
   After a lot of tinkering I finally got my animate function to work, succeeding in getting insertion sort to work. From here the progress was going to start increasing very fast. However, before that happened I ran into another issue and made some massive changes. I realized using an array of arrays to hold moves was both inefficent and was confusing to code, so I made a switch to using objects, holding an array of indexes, of size 2, and anotehr array to see if the move at its same index was a swap or not. This helped clear up the code alot. From here I coded up selectionSort easily and wrote in the plan generator, however I ran into an issue when it came to animating. My animating function wasnt doing what I wanted it to do, making elements yellow if the pointer was moving but not swapping. After an immense amount of playing around with the animating function I got this to work. I then coded up insertionSort and the plan generation and animation worked flawlessly. 

   Before I tackled the hard algorithms: mergeSort and quickSort, I made some quality of life changes in the code. I readjusted the location of variables such as nomber of elements and speed to the state and cleaned up my code as a whole to make it easier as I went forward. As I was able to easily finish my first three algorithms I rushed into coding up and animating quicksort thinking it would be easy. However I was very mistaken, and I had an abundent of errors.

## Day 5    
   My first issue and move apparent was my plan generation for quickSort was not working at all, this had to do with the simple fact that quickSort used recursion, or so I believed. After creating a jank solution of having an emptyPlan pass into every recursive call and once that call was over concatonate the values to my original bigger plan. While I believed this to work, I saw that in reality I had a major flaw in my quickSort algorithm. After just playing aound with my code hoping something would change, I scrapped the code and rewrote, still having an error. Here I went back to the basics, I got out a paper wrote out an array of length 10 and worked it out on paper, then I had my algorithm sort the same array and print the array out after every swap. From here I was able to get my quickSort to work, however I had another problem I soon realized later, my code didnt work for a specific weird case; it would sort some arrays but not others. I took and array it wasnt able to sort and did the same process, I found out that the edge case it was not able to sort was when the partition value was the largest element in the array. After fixing that I then finally had a working quick sort which was able to be visualized.

    

## Day 6 
   I had one algorithm left, Merge Sort, the hardest one out of the 5; this is for the sole reason that the merge sort algorithm I learned created new arrays which messed with index arrays. After reasearch online a way to get around this I learned about an inplace version of merge sort, which still had an O(nlog(n)) time complexity but this time and O(1) space complexity, O(n) if we count storing the array. Reading and watching videos I was super confused on how this worked, however after making some practive arrays and working through them on paper I was soon able to start understanding how inplace merge sort worked. In place merge sort worked the same as out of place merge sort when it came to "seperating" the different blocks of array. however differed a lot when merging the arrays together. After glancing at some code online and jumping in and trying myself I was soon able to figure out and get merge sort to work. And finally after some more tinkering I was able to finally get merge sort working and get it animated. 

## Day 7
   I did a little buit of cleanup, I tried research on how to seperate the header into another component and have it work together with the sorter visualizer, however I ended up getting very confused, so for now to get a basic idea down, I made the header with the buttons in the sorter visualizer component. I then cleaned up some of the UI, adding a slider to adjust the speed and number of elements. I had some issues with having a slider working, however I learned about react gui elements. Using the react-slider I was able to have it show up on the screen and have the slider actually move. The next step was taking this value and making it change the number of elements, after some playing around I found out using a lambda function with OnChange worked, and was able to get that part working. 
